#include "iarduino_Frequency.h"															//
																						//
//	ФУНКЦИЯ ЧТЕНИЯ ЧАСТОТЫ:																//
float frequencyRead(uint8_t _pin, uint16_t _jump, uint16_t _mean){						//	_pin - номер аналогового вывода, _jump - шум сигнала, _mean - коэффициент усреднения частоты.
																						//
//		Определяем переменные static:													//
		static uint8_t  sum=0;															//	Количество активных каналов (не более 4).
		static uint8_t  pin[4]={  255,   255,   255,   255};							//	Массив выводов активных каналов.
		static uint16_t jmp[4]={  100,   100,   100,   100};							//	Шум сигнала. Функция не будет реагировать на указанный шум.
		static uint16_t mea[4]={    1,     1,     1,     1};							//	Коэффициент усреднения частоты.
		static bool     dir[4]={    0,     0,     0,     0};							//	Направление сигнала: 1-вверх / 0-вниз.
		static float    fre[4]={ 0.0f,  0.0f,  0.0f,  0.0f};							//	Частота сигнала.
		static uint32_t tim[4]={    0,     0,     0,     0};							//	Время последнего усреднения частоты.
		static uint16_t max[4]={    0,     0,     0,     0};							//	Последний зафиксированный максимум.
		static uint32_t tmx[4]={    0,     0,     0,     0};							//	Время фиксации последнего максимума в мкс.
		static uint32_t pmx[4]={    0,     0,     0,     0};							//	Время фиксации предыдущего максимума участвующего в рассчётах частоты в мкс.
		static uint32_t Tmx[4]={    0,     0,     0,     0};							//	Период пиков максимума в мкс.
		static uint16_t min[4]={65535, 65535, 65535, 65535};							//	Последний зафиксированный минимум.
		static uint32_t tmn[4]={    0,     0,     0,     0};							//	Время фиксации последнего минимума в мкс.
		static uint32_t pmn[4]={    0,     0,     0,     0};							//	Время фиксации предыдущего минимума участвующего в рассчётах частоты в мкс.
		static uint32_t Tmn[4]={    0,     0,     0,     0};							//	Период пиков минимума в мкс.
																						//
//		Определяем номер канала:														//
		uint8_t i=0;																	//
		while( pin[i]!=_pin ){															//	Выходим из цикла если канал найден.
			if(pin[i]==255  ){ pin[i]=_pin; sum++; } else								//	Создаём новый канал.
			if( i<4         ){              i++;   } else { return 0.0f; }				//	Переходим к следующему каналу или выходим.
		}																				//
																						//
//		Сохраняем указанный шум сигнала:												//
		if( _jump<65535 ){ jmp[i]=_jump; }												//
																						//
//		Сохраняем указанный коэффициент усреднения частоты:								//
		if( _mean<65535 && _mean ){ mea[i]=_mean; }										//
																						//
//		Читаем уровень сигнала:															//
		uint16_t val = analogRead( pin[i] );											//
																						//
//		Если сигнал растёт:																//
		if( dir[i] ){																	//
			if(  val         > max[i] ){ max[i]=val; tmx[i]=micros();  }				//	Находим максимум.
			if( (val+jmp[i]) < max[i] ){ min[i]=max[i]; dir[i]=0; Tmx[i]=tmx[i]-pmx[i]; pmx[i]=tmx[i]; } //	Если текущий уровень ниже последнего зафиксированного максимума, значит сигнал начал снижаться.
//		Если сигнал снижается:															//
		}else{																			//
			if( val <  min[i]         ){ min[i]=val; tmn[i]=micros();  }				//	Находим минимум.
			if( val > (min[i]+jmp[i]) ){ max[i]=min[i]; dir[i]=1; Tmn[i]=tmn[i]-pmn[i]; pmn[i]=tmn[i]; } //	Если текущий уровень выше последнего зафиксированного минимума, значит сигнал начал расти.
		}																				//
																						//
//		Сбрасываем периоды:																//
		if( micros()-pmx[i] > 1000000 ){ Tmx[i]=0; fre[i]=0; }							//
		if( micros()-pmn[i] > 1000000 ){ Tmn[i]=0; fre[i]=0; }							//
																						//
//		Определяем и усредняем частоту по времени:										//
		if( tim[i] < (millis()-20) ){													//	Если прошло 20 мс.
			tim[i] = millis();															//	Сохраняем время усреднения частоты.
			uint32_t period = Tmx[i]>Tmn[i]? Tmx[i]:Tmn[i];								//	Определяем максимальный период между пиками минимумов и максимумов.
			if( period==0 ){ return 0.0f; }												//
			fre[i] *= (float)mea[i];													//	Умножаем предыдущий результат fre[i] на коэффициент усреднения mea[i].
			fre[i] += 1000000.0f/(float)period;											//	Добавляем к полученному значению текущий результат.
			fre[i] /= (float)mea[i]+1.0f;												//	Делим полученное значение на коэффициент усреднения.
		}																				//
																						//
//		Возвращаем частоту:																//
		return fre[i];																	//	Возвращаем частоту из периода, округлив её до целого числа.
}																						//
																						//
void  frequencyJump(uint8_t pin, uint16_t jump){ frequencyRead(pin, jump , 65535); }	// Указание величины шума сигнала в значениях АЦП (указанный шум не будет влиять на частоту).
void  frequencyMean(uint8_t pin, uint16_t mean){ frequencyRead(pin, 65535, mean ); }	// Указание коэффициента усреднения частоты.
